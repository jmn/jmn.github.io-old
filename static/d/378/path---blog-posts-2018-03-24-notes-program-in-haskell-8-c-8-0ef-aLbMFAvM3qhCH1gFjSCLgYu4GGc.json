{"data":{"markdownRemark":{"html":"<p>A small Haskell program that manages short notes in a SQLite database. Uses <a href=\"https://hackage.haskell.org/package/sqlite-simple\">sqlite-simple</a> and <a href=\"https://hackage.haskell.org/package/cmdargs\">CmdArgs</a>.</p>\n<!--more-->\n<pre><code class=\"language-haskell\">{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE DeriveDataTypeable #-}\n\nmodule Main where\n\nimport System.Environment (getArgs)\nimport Database.SQLite.Simple\nimport System.Console.CmdArgs\nimport Data.List hiding (delete)\nimport Data.Time.Format.Human\nimport Data.Time\nimport Data.Time.Format\nimport Control.Monad (when)\n\ndata Options = Options\n    { inputMode :: Bool\n    , message :: String\n    , delete :: Integer\n    , humanTime :: Bool\n    , tags :: Maybe String\n    , update :: Integer\n    , showTag :: Maybe String\n    } deriving (Data, Typeable)\n\noptions :: Options\noptions =\n    Options\n    { inputMode = False &#x26;= typ \"Input mode\" &#x26;= help \"Toggle input mode\"\n    , message = def &#x26;= typ \"message\" &#x26;= opt (\"\" :: String) &#x26;= args\n    , delete = def &#x26;= typ \"[number]\" &#x26;= help \"Delete a note.\"\n    , humanTime =\n        False &#x26;= typ \"Relative time\" &#x26;= help \"Show time relative to now in human readable format.\"\n    , tags = def &#x26;= typ \"tags\" &#x26;= help \"Tag a note.\"\n    , update = def &#x26;= typ \"[number]\" &#x26;= help \"Modify a note.\"\n    , showTag = def &#x26;= typ \"TAG\" &#x26;= help \"Show entries with given tag.\"\n    } &#x26;=\n    summary \"n notes\" &#x26;=\n    program \"n\"\n\ndata TestField = TestField\n    { id_ :: Int\n    , time :: String\n    , note :: String\n    , tags' :: Maybe String\n    } deriving (Show)\n\ninstance FromRow TestField where\n    fromRow = TestField &#x3C;$> field &#x3C;*> field &#x3C;*> field &#x3C;*> field\n\ninstance ToRow TestField where\n    toRow (TestField id_ date_added str str') = toRow (id_, date_added, str, str')\n\ndbPut :: Connection -> String -> Maybe String -> IO ()\ndbPut conn val mTags =\n    case mTags of\n        Nothing ->\n            execute\n                conn\n                \"INSERT INTO test (date_added, str) \\\n        \\VALUES (datetime('now'), ?)\"\n                (Only (val :: String))\n        tags ->\n            execute\n                conn\n                \"INSERT INTO test (date_added, str, tags) \\\n        \\VALUES (datetime('now'), ?, ?)\"\n                (val :: String, tags)\n\ndeleteRecord :: Connection -> Integer -> IO ()\ndeleteRecord conn x = execute conn \"DELETE FROM test WHERE ID = (?)\" (Only x)\n\nshowNote :: Bool -> TestField -> IO ()\nshowNote humanizeTime x = do\n    time' &#x3C;- if humanizeTime then\n        do let t = parseTimeOrError False defaultTimeLocale \"%F %T\" (time x) :: UTCTime\n           humanReadableTime t\n    else\n           return (time x)\n    t &#x3C;-\n        case tags' x of\n            Nothing -> return \"\"\n            Just xs -> return $ \"#\" ++ xs\n\n    let msg = note x ++ \" \" ++ t\n    let o = intercalate \" | \" [show (id_ x), time', msg]\n    print o\n\ncreateTable conn =\n    execute_\n        conn\n        \"CREATE TABLE IF NOT EXISTS \\\n        \\test (id INTEGER PRIMARY KEY, \\\n        \\date_added DATETIME DEFAULT CURRENT_TIMESTAMP, \\\n        \\str TEXT, \\\n        \\tags TEXT)\"\n\nmain :: IO ()\nmain = do\n    opts &#x3C;- cmdArgs options\n    conn &#x3C;- open \"test.db\"\n    createTable conn\n    when (delete opts /= 0) (deleteRecord conn (delete opts))\n    when (message opts /= \"\") (dbPut conn (message opts) (tags opts))\n    when\n        (inputMode opts)\n        (do content &#x3C;- getContents\n            dbPut conn content (tags opts))\n    r &#x3C;-\n        case showTag opts of\n            Nothing -> query_ conn \"SELECT * from test\" :: IO [TestField]\n            Just x -> query conn \"SELECT * from test WHERE tags LIKE ?\" (Only x) :: IO [TestField]\n    if humanTime opts\n        then mapM_ (showNote True) r\n        else mapM_ (showNote False) r\n    close conn\n</code></pre>","frontmatter":{"title":"Note recording Haskell program"}}},"pageContext":{"slug":"/blog-posts/2018-03-24-notes-program-in-haskell/"}}