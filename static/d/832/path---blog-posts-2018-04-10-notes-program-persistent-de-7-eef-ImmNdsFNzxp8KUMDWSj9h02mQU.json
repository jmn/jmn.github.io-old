{"data":{"markdownRemark":{"html":"<p>Here's a version of <a href=\"https://www.jmnorlund.net/log/2018/03/notes-program-in-haskell\">the previous notes program</a> that uses Persistent. </p>\n<!--more-->\n<p>The imports are: </p>\n<ul>\n<li>text</li>\n<li>cmdargs</li>\n<li>friendly-time</li>\n<li>time</li>\n<li>persistent</li>\n<li>persistent-sqlite</li>\n<li>persistent-template</li>\n<li>transformers</li>\n</ul>\n<pre><code class=\"language-haskell\">{-# LANGUAGE DeriveDataTypeable #-}\n{-# LANGUAGE EmptyDataDecls #-}\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE GADTs #-}\n{-# LANGUAGE GeneralizedNewtypeDeriving #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE OverloadedStrings #-}\n{-# LANGUAGE QuasiQuotes #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeFamilies #-}\n\nmodule Main where\n\nimport System.Console.CmdArgs\nimport Control.Monad (when, void)\nimport Database.Persist\nimport Database.Persist.TH\nimport Database.Persist.Sqlite\nimport Control.Monad.IO.Class (liftIO)\nimport Control.Monad.Trans.Reader\nimport Data.Time\nimport Data.List (intercalate)\nimport Data.Time.Format.Human\n\nshare\n    [mkPersist sqlSettings, mkMigrate \"migrateAll\"]\n    [persistLowerCase|\nNote\n    message String\n    tags String Maybe\n    createdAt UTCTime default=CURRENT_TIME\n    deriving Show\n|]\n\ndata Options = Options\n    { inputMode :: Bool\n    , message :: String\n    , delete :: Integer\n    , humanTime :: Bool\n    , tags :: Maybe String\n    , update :: Integer\n    , showTag :: Maybe String\n    } deriving (Data, Typeable)\n\noptions :: Options\noptions =\n    Options\n    { inputMode = False &#x26;= typ \"Input mode\" &#x26;= help \"Toggle input mode\"\n    , message = def &#x26;= typ \"message\" &#x26;= opt (\"\" :: String) &#x26;= args\n    , Main.delete = def &#x26;= typ \"[number]\" &#x26;= help \"Delete a note.\"\n    , humanTime =\n        False &#x26;= typ \"Relative time\" &#x26;= help \"Show time relative to now in human readable format.\"\n    , tags = def &#x26;= typ \"tags\" &#x26;= help \"Tag a note.\"\n    , Main.update = def &#x26;= typ \"[number]\" &#x26;= help \"Modify a note.\"\n    , showTag = def &#x26;= typ \"TAG\" &#x26;= help \"Show entries with given tag.\"\n    } &#x26;=\n    summary \"n notes\" &#x26;=\n    program \"n\"\n\nshowNote :: Bool -> Entity Note -> IO ()\nshowNote humanizeTime note = do\n    let n = entityVal note\n    let t' = noteCreatedAt n\n    let key = show $ fromSqlKey $ entityKey note\n    time &#x3C;-\n        if humanizeTime\n            then humanReadableTime t'\n            else return $ show t'\n    t &#x3C;-\n        case noteTags n of\n            Nothing -> return \"\"\n            Just xs -> return $ \"#\" ++ xs\n    let o = intercalate \" | \" [key, time, show (noteMessage n), t]\n    print o\n\n\nasSqlBackendReader :: ReaderT SqlBackend m a -> ReaderT SqlBackend m a\nasSqlBackendReader = id\n\nmain :: IO ()\nmain =\n    runSqlite \"testn.db\" $\n    asSqlBackendReader $\n    do opts &#x3C;- liftIO $ cmdArgs options\n       runMigration migrateAll\n       time &#x3C;- liftIO getCurrentTime\n       when (message opts /= \"\") $ void $ insert $ Note (message opts) (tags opts) time\n       when\n           (inputMode opts)\n           (do content &#x3C;- liftIO getContents\n               void $ insert $ Note content (tags opts) time\n               return ())\n       when\n           (Main.delete opts /= 0)\n           (do let key = toSqlKey $ fromIntegral (Main.delete opts) :: Key Note\n               Database.Persist.Sqlite.delete key)\n       notes &#x3C;-\n           case showTag opts of\n               Nothing -> selectList [] [Asc NoteCreatedAt]\n               Just x -> selectList [NoteTags ==. Just x] [Asc NoteCreatedAt]\n       if humanTime opts\n           then liftIO $ mapM_ (showNote True) notes\n           else liftIO $ mapM_ (showNote False) notes\n</code></pre>","frontmatter":{"title":"Haskell Persistent note recording program"}}},"pageContext":{"slug":"/blog-posts/2018-04-10-notes-program-persistent/"}}